---
title: 洛谷P1403约数研究
date: 2018-11-29 18:29:55
tags: 题目
categories: 题目
mathjax: true
---

#### 题目描述

定义 $\delta$ (i)表示正整数i的约数个数， f(n)= $\sum_{i=1}^n$ $\delta$  (i).

<!--more-->

#### 输入格式

输入一行，一个正整数n.

#### 输出格式

输出一行，一个正整数f(n).

#### 数据范围

20% N <= 5000

100% N <= 1000000

#### 思路

首先，打个暴力还是有的吧：

```c++
REP(i,1,n) REP(j,1,i)
    if(i%j==0) ans++;
```

当然这个暴力的复杂度接近$n^2$ ，是不可以的，所以我们考虑优化

经过一番思考，发现此种构造似乎无法继续优化

（ i 从 1 到 n 表示枚举每个数，j 从1 到 i 表示枚举数字i可能的约数，似乎已经是最优）因此考虑稍稍变形

##### 我们不难发现一个性质： 如果y是x的约数那么y也是x的倍数的约数

因此可以选择枚举一个约数y，再枚举一个以y为约数的数字x，显然第一个 x = *y，第二个 x= 2*y，以此类推……

那么这样第二重循环的复杂度大大降低，我们就得到了一个类似筛法的算法：

```c++
REP(i,1,n) for(int j=i;j<=n;j+=i)
    sum[j]++;//sum数组存数字j的约数个数
REP(i,1,n) ans+=sum[i];
```

据说此种方法可以 AC 本题，但还不是一个比较满意的答案（因为点开标签 ~~题解~~ 得知了这是一道数论题）

那么继续考虑优化上述的筛法：i 循环是在 求 1 到 n 中含有约数 i 的数字的个数 ，那么有没有更简便的方法呢？

模拟一下计算过程：能整除sum就加 1 ，如此往复，问题转化为：求 1 到 n 中能整除 i 的数字的个数

这样经过思考，我们不难得出公式$\lfloor$ $\frac{n}{i}$ $\rfloor$  ，证明 ~~感性理解~~ 如下：

```c++
从 1 开始的每 i 个数中就有1个数可以被i整除，因此在 1 到 n 共n个数中总数是 n/i 下取整
```

由此的代码：

```c
REP(i,1,n) ans+=n/i;
```

至此本题解决（bht大佬tql，靠自己观察数据加短除法推出了上式）

当然，以上思路也可以用及其严谨的数学方法证明（转自题解区某dalao）：

首先定义 d|i 表示 i %d==0

 f(n)= $\sum_{i=1}^n$ $\delta$ (i)

 f(n)= $\sum_{i=1}^n$  $\sum_{d|i}$ 1

 f(n)= $\sum_{i=1}^n$  $\sum_{d=1}^n$d|i

 f(n)= $\sum_{d=1}^n $  $\sum_{i=1}^n$ d|i

 f(n)= $\sum_{d=1}^n$  $\lfloor\frac {n}{d} $$\rfloor$  证毕



